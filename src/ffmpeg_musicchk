#!/bin/ksh

#
#
# Copyright (c) 2023 Piotr Trzpil  p.trzpil@protonmail.com
#
# Permission to use, copy, modify, and distribute 
# this software for any purpose with or without fee
# is hereby granted, provided that the above copyright
# notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR
# DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE
# FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
# OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
#
#



if ! utilchk 'ffprobe' 'ffmpeg' 'ffmpeg_fullsupformat' 'optchk'
then

  printf "Missing utilities.\n" >&2
  exit 1

fi


manual()  {

  printf "This program expects at leats one argument\n" >&2
  printf "Possible arguments:" >&2
  printf "options followed at end by path to music file\n" >&2
  printf "Options:\n" >&2
  printf "-R recurse directory for excel files\n" >&2
  printf "-d use only excel files in this directory\n" >&2
  printf "-h show this text\n" >&2
  exit 1  # TODO add -- to invoke end of options

}

if (( $# < 1 )) 
then

  manual

fi

set -A argslist -- "$@"

# Last passed argument should be path so we save it and remove
path_arg="${argslist[ ${#argslist[@]} - 1 ]}"
unset  "argslist[ ${#argslist[@]} - 1 ]"

optlist="dRh"
optstr="$( optchk "${argslist[@]}" "$optlist" )" || manual

opt_d=0
opt_R=0
[[ $optstr == *'h'* ]] && manual
[[ $optstr == *'d'* ]] && opt_d=1
[[ $optstr == *'R'* ]] && opt_R=1

if (( opt_d && opt_R ))
then

  printf "You can't set both d and R options\n" >&2

fi

# regular file
if ! (( opt_d || opt_R ))
then

  if ! test -f "$path_arg"
  then

    printf "Specified file is not regular file\n" >&2
    exit 2

  fi

  detected_format="$( ffprobe -show_format "$path_arg" 2>/dev/null \
    | grep -Fi 'format_name' | tr -s "[:upper:]" "[:lower:]" )"
  detected_format="${detected_format##*=}"

  if [[ $detected_format == '' ]]
  then

    printf "Can't detect file format: %s\n" \
    "$path_arg" >&2
    exit 3

  fi

  file_format="$( echo "${path_arg##*.}" | tr -s "[:upper:]" "[:lower:]" )"

  if [[ $detected_format != "$file_format" ]]
  then

    printf "Problem with format on file: %s\n" "$apath_arg" >&2
    printf "File extension does not match detected file format\n" >&2
    printf "File extension: %s\nFile format: %s\n" \
      "$file_format" "$detected_format" >&2
    exit 3

  fi

  tf="$( mktemp )"
  ffmpeg_fullsupformat | tr -s "[:upper:]" "[:lower:]" > "$tf"
  supported=0

  while IFS= read -r format
  do

    format='.'"${format#*.}"
    if [[ '.'$file_format == *"$format" ]]
    then

      supported=1
      break

    fi

  done < "$tf"

  rm -f "$tf"

  if (( supported == 0 ))
  then

    printf "File format: is not supported by ffmpeg.\n" "" >&2
    exit 3

  fi

  testvar=''
  testvar="$( ffprobe -loglevel 'warning' "$path_arg" 2>&1 )"
  if test -n "$testvar"
  then

    printf "Detected bugs in file: %s\n" "$path_arg" >&2
    exit 3

  fi

  exit

fi

# directory
if ! test -d "$path_arg"
then

  printf "Specified file is not directory file\n" >&2
  exit 2

fi

tf="$( mktemp )"
tf2="$( mktemp )"
tf3="$( mktemp )"

ffmpeg_fullsupformat > "$tf3"

depth=''
(( opt_d )) && depth='-maxdepth 1'

find_inamelist "$path_arg" -type f $depth < "$tf3" > "$tf2"

found_bugs=0

while IFS= read -r file
do

  detected_format="$( ffprobe -show_format "$file" 2>/dev/null \
    | grep -Fi 'format_name' | tr -s "[:upper:]" "[:lower:]" )"
  detected_format="${detected_format##*=}"

  if [[ $detected_format == '' ]]
  then

    printf "Can't detect file format: %s\n" \
     "$file" >&2
    found_bugs=1
    continue

  fi

  file_format="$( echo "${file##*.}" | tr -s "[:upper:]" "[:lower:]" )"

  if [[ $detected_format != "$file_format" ]]
  then

    printf "Problem with format on file: %s\n" "$file" >&2
    printf "File extension does not match detected file format\n" >&2
    printf "File extension: %s\nFile format: %s\n" \
      "$file_format" "$detected_format" >&2
    found_bugs=1
    continue

  fi

  tr -s "[:upper:]" "[:lower:]" < "$tf3" > "$tf"
  supported=0

  while IFS= read -r format
  do

    format='.'"${format#*.}"
    if [[ '.'$file_format == *"$format" ]]
    then

      supported=1
      break

    fi

  done < "$tf"

  if (( supported == 0 ))
  then

    printf "File format: is not supported by ffmpeg.\n" "" >&2
    found_bugs=1
    continue

  fi

  testvar=''
  testvar="$( ffprobe -loglevel 'warning' "$file" 2>&1 )"
  if test -n "$testvar"
  then

    printf "Detected bugs in file: %s\n" "$file" >&2
    found_bugs=1
    continue

  fi

done < "$tf2"

rm -f "$tf" "$tf2" "$tf3"

if (( found_bugs ))
then

  exit 3

fi








